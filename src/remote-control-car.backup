#include <Arduino.h>     // åŒ…å« Arduino æ ¸å¿ƒå‡½å¼åº«
#include <WiFi.h>        // åŒ…å« Wi-Fi å‡½å¼åº«
#include <ESPmDNS.h>     // åŒ…å« mDNS å‡½å¼åº«ï¼Œç”¨æ–¼é€éä¸»æ©Ÿåç¨±è¨ªå•
#include <WiFiUdp.h>     // åŒ…å« UDP å‡½å¼åº«ï¼ŒOTA éœ€è¦ä½¿ç”¨
#include <ArduinoOTA.h>  // åŒ…å« Arduino OTA å‡½å¼åº«
#include <WebServer.h>   // åŒ…å«ç¶²é ä¼ºæœå™¨å‡½å¼åº« (åŒæ­¥å¼çš„ WebServer)
#include <ArduinoJson.h> // ç”¨æ–¼è™•ç† JSON æ•¸æ“šï¼Œä¾‹å¦‚ç™¼é€æ„Ÿæ¸¬å™¨ç‹€æ…‹

// å‡½å¼å‰å‘å®£å‘Š (Function prototypes)
void stopMotors();
void moveForward(int speed);
void moveBackward(int speed);
void turnLeft(int speed);
void turnRight(int speed);
void updateLED(); // LED ç‹€æ…‹æ›´æ–°å‡½å¼
void handleCarCommand(char command); // çµ±ä¸€è™•ç†è»Šè¼›æŒ‡ä»¤

// Wi-Fi è¨­å®š
const char* ssid = "chen";     // æ›¿æ›æˆæ‚¨çš„ Wi-Fi åç¨±
const char* password = "12345678"; // æ›¿æ›æˆæ‚¨çš„ Wi-Fi å¯†ç¢¼
const char* ota_hostname = "car-esp32c3"; // OTA è£ç½®åœ¨ç¶²è·¯ä¸Šçš„åç¨±
// const char* ota_password = "admin"; // å¦‚æœéœ€è¦ OTA å¯†ç¢¼ï¼Œè«‹å–æ¶ˆè¨»è§£ä¸¦è¨­å®š

// æ§åˆ¶æ¨¡å¼å®šç¾©
enum ControlMode {
  AUTO_CONTROL,   // è‡ªå‹•æ§åˆ¶æ¨¡å¼ (å¾ªç·š/é¿éšœ)
  MANUAL_CONTROL  // æ‰‹å‹•æ§åˆ¶æ¨¡å¼ (ç¶²é æŒ‡ä»¤)
};
ControlMode currentControlMode = MANUAL_CONTROL; // é è¨­ç‚ºæ‰‹å‹•æ§åˆ¶æ¨¡å¼

// é¦¬é”é è¨­é€Ÿåº¦ (0-255ï¼Œå–æ±ºæ–¼ PWM_RESOLUTION)
const int STRAIGHT_SPEED = 200; // ç›´è¡Œé€Ÿåº¦
const int TURN_SPEED = 200;     // è½‰å‘æ™‚è¼ƒå¿«çš„é¦¬é”é€Ÿåº¦ (ç”¨æ–¼åŸåœ°è½‰å‘æˆ–å¤§è½‰å½)
const int TURN_SLOW_SPEED = 200; // è½‰å‘æ™‚è¼ƒæ…¢çš„é¦¬é”é€Ÿåº¦ (ç”¨æ–¼å¾®èª¿)
const int STOP_SPEED = 0;       // åœæ­¢é€Ÿåº¦
/*
const int STRAIGHT_SPEED = 250; // ç›´è¡Œé€Ÿåº¦
const int TURN_SPEED = 200;     // è½‰å‘æ™‚è¼ƒå¿«çš„é¦¬é”é€Ÿåº¦ (ç”¨æ–¼åŸåœ°è½‰å‘æˆ–å¤§è½‰å½)
const int TURN_SLOW_SPEED = 150; // è½‰å‘æ™‚è¼ƒæ…¢çš„é¦¬é”é€Ÿåº¦ (ç”¨æ–¼å¾®èª¿)
const int STOP_SPEED = 0;       // åœæ­¢é€Ÿåº¦
*/
// æ„Ÿæ¸¬å™¨é–¾å€¼
// æ­¤å€¼éœ€è¦æ ¹æ“šæ‚¨çš„ TCRT5000 æ„Ÿæ¸¬å™¨å’Œç’°å¢ƒé€²è¡Œæ ¡æº–ã€‚
// å‡è¨­è®€æ•¸ä½æ–¼æ­¤é–¾å€¼è¡¨ç¤ºåµæ¸¬åˆ°éšœç¤™ç‰©æˆ–æ·±è‰²ç·šã€‚
const int OBSTACLE_THRESHOLD = 300; // èª¿æ•´æ­¤å€¼

// é¦¬é”æ§åˆ¶è…³ä½å®šç¾©
// ==== è¨­å®š ==== //
#define MOTOR_SDBY  7
#define MOTOR_A_IN1 20
#define MOTOR_A_IN2 21
#define MOTOR_B_IN3 5
#define MOTOR_B_IN4 6

// TCRT5000 å¾ªç·šæ„Ÿæ¸¬å™¨çš„é¡æ¯”è¼¸å…¥å¼•è…³
const int LEFT_SENSOR_PIN = 0;  // å·¦é‚Š TCRT5000 A0 æ¥åˆ° ESP32-C3 çš„ GPIO4
const int RIGHT_SENSOR_PIN = 0; // å³é‚Š TCRT5000 A0 æ¥åˆ° ESP32-C3 çš„ GPIO3

// æ¿è¼‰ LED è…³ä½
const int LED_PIN = 8;

// å‹•ä½œç‹€æ…‹å®šç¾©
enum MotionState { STOPPED, FORWARD, BACKWARD, TURN_LEFT, TURN_RIGHT, OTHER };
MotionState currentMotionState = STOPPED; // ä½¿ç”¨ä¸åŒçš„è®Šæ•¸åé¿å…èˆ‡ currentControlMode è¡çª

unsigned long lastBlinkTime = 0;
bool ledState = false;

// å…¨å±€æ——æ¨™ï¼Œç”¨æ–¼è¿½è¹¤ Wi-Fi é€£ç·šç‹€æ…‹
bool wifiConnected = false;

// å…¨å±€è®Šæ•¸ï¼Œç”¨æ–¼æ§åˆ¶åºåˆ—åŸ å’Œç¶²é æ„Ÿæ¸¬å™¨é¡¯ç¤ºçš„é‚è¼¯
static bool stoppedMessagePrinted = false;

// Web Server ç‰©ä»¶
WebServer server(80); // ç¶²é ä¼ºæœå™¨ç›£è½ 80 åŸ 

// çµ±ä¸€è™•ç†è»Šè¼›æŒ‡ä»¤çš„å‡½å¼
void handleCarCommand(char command) {
    String responseMessage = "";

    switch (command) {
        case 'A': // åˆ‡æ›åˆ°è‡ªå‹•æ§åˆ¶æ¨¡å¼
            currentControlMode = AUTO_CONTROL;
            responseMessage = "Switched to AUTO_CONTROL mode.";
            break;
        case 'M': // åˆ‡æ›åˆ°æ‰‹å‹•æ§åˆ¶æ¨¡å¼
            currentControlMode = MANUAL_CONTROL;
            responseMessage = "Switched to MANUAL_CONTROL mode.";
            stopMotors(); // åˆ‡æ›æ¨¡å¼æ™‚åœæ­¢é¦¬é”
            break;
        case 'F': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å‰
            if (currentControlMode == MANUAL_CONTROL) {
                moveForward(STRAIGHT_SPEED);
                responseMessage = "Moving Forward.";
            }
            break;
        case 'B': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å¾Œ
            if (currentControlMode == MANUAL_CONTROL) {
                moveBackward(STRAIGHT_SPEED);
                responseMessage = "Moving Backward.";
            }
            break;
        case 'L': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å·¦è½‰
            if (currentControlMode == MANUAL_CONTROL) {
                turnLeft(TURN_SPEED);
                responseMessage = "Turning Left.";
            }
            break;
        case 'R': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å³è½‰
            if (currentControlMode == MANUAL_CONTROL) {
                turnRight(TURN_SPEED);
                responseMessage = "Turning Right.";
            }
            break;
        case 'S': // æ‰‹å‹•æ¨¡å¼ï¼šåœæ­¢
            if (currentControlMode == MANUAL_CONTROL) {
                stopMotors();
                responseMessage = "Stopping Motors.";
            }
            break;
        default:
            responseMessage = "Unknown Command.";
            break;
    }
    Serial.println(responseMessage);
}

// -------- WiFi é€£ç·š --------
void connectToWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("ğŸ”Œ Connecting to WiFi");

  unsigned long startAttemptTime = millis();

  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000) {
    Serial.print(".");
    delay(500);
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nâœ… WiFi Connected");
    Serial.print("ğŸŒ IP Address: ");
    wifiConnected = true; // è¨­å®š Wi-Fi é€£ç·šæ——æ¨™ç‚º true
    digitalWrite(LED_PIN, LOW); // Wi-Fi é€£ç·šæˆåŠŸå¾Œï¼ŒLED ç†„æ»…
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nâŒ WiFi Failed");
    Serial.print("WiFi Status Code: ");
    Serial.println(WiFi.status());
  }
}

// -------- OTA åˆå§‹åŒ– --------
void setupOTA() {
  ArduinoOTA.setHostname(ota_hostname);

  ArduinoOTA.onStart([]() {
    Serial.println("ğŸ” OTA Start");
  });
  ArduinoOTA.onEnd([]() {
    Serial.println("âœ… OTA End");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("ğŸ“¦ Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("âŒ OTA Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });

  ArduinoOTA.begin();
  Serial.println("ğŸ†— OTA Ready.");
}

void controlByJoystick(int steer, int throttle) {
  if (abs(throttle) > 20 && abs(steer) <= 20) {
    // åƒ…ç§»å‹•
  } else if (abs(throttle) <= 20 && abs(steer) > 20) {
    // åƒ…è½‰å‘ï¼ˆåŸåœ°è½‰ï¼‰
  } else if (abs(throttle) > 20 && abs(steer) > 20) {
    // ç§»å‹•+è½‰å‘ï¼ˆå¯è€ƒæ…®å¯¦ä½œå·®é€Ÿæ§åˆ¶ï¼‰
  }

  // èˆ‰ä¾‹é‚è¼¯ï¼šY è»¸æ§åˆ¶å‰å¾Œï¼ŒX è»¸æ§åˆ¶æ–¹å‘
  if (throttle > 20) {
    moveForward(map(throttle, 0, 100, 0, 255));
  } else if (throttle < -20) {
    moveBackward(map(-throttle, 0, 100, 0, 255));
  } else {
    stopMotors();
  }

  if (steer > 20) {
    turnRight(map(steer, 0, 100, 0, 255));
  } else if (steer < -20) {
    turnLeft(map(-steer, 0, 100, 0, 255));
  }
}

// -------- Web Server åˆå§‹åŒ– --------
void startWebServer() {
  // --- ç¶²é ä¼ºæœå™¨è·¯ç”±è¨­å®š ---
  // è™•ç†æ ¹è·¯å¾‘è«‹æ±‚ï¼Œæä¾› HTML æ§åˆ¶é é¢
  server.on("/", HTTP_GET, [](){
    server.sendHeader("Location", "https://physical-ai.tw/tools/remote-joystick");
    server.send(302, "text/plain", "Redirecting to remote control interface...");
  });

  // è™•ç†æ§åˆ¶æŒ‡ä»¤ (GET è«‹æ±‚)
  server.on("/control", HTTP_GET, []() {
    if (server.hasArg("cmd")) {
      // åŸæœ¬çš„ç°¡æ˜“æŒ‡ä»¤æ§åˆ¶
      String cmd = server.arg("cmd");
      handleCarCommand(cmd.charAt(0));
      server.send(200, "text/plain", "Command received: " + cmd);
    }
    else if (server.hasArg("steer") && server.hasArg("throttle")) {
      int steer = server.arg("steer").toInt();       // -100 ~ 100
      int throttle = server.arg("throttle").toInt(); // -100 ~ 100
      controlByJoystick(steer, throttle);
      server.send(200, "text/plain", "Joystick command received.");
    } else {
      server.send(400, "text/plain", "Missing command");
    }
  });
/*
  server.on("/control", HTTP_GET, [](){
    if (server.hasArg("cmd")) {
      String cmd = server.arg("cmd");
      handleCarCommand(cmd.charAt(0)); // çµ±ä¸€è™•ç†æŒ‡ä»¤
      server.send(200, "text/plain", "Command received: " + cmd);
    } else {
      server.send(400, "text/plain", "No command specified");
    }
  });
*/
  // è™•ç†æ¨¡å¼åˆ‡æ›æŒ‡ä»¤ (GET è«‹æ±‚)
  server.on("/mode", HTTP_GET, [](){
    if (server.hasArg("set")) {
      String mode = server.arg("set");
      handleCarCommand(mode.charAt(0)); // 'A' æˆ– 'M'
      server.send(200, "text/plain", "Mode set to: " + mode);
    } else {
      server.send(400, "text/plain", "No mode specified");
    }
  });

  // æä¾›æ„Ÿæ¸¬å™¨ç‹€æ…‹ (JSON æ ¼å¼)
  server.on("/status", HTTP_GET, [](){
    StaticJsonDocument<200> doc; // ArduinoJson æ–‡æª”
    doc["mode"] = (currentControlMode == AUTO_CONTROL) ? "AUTO" : "MANUAL";

    // å»ºè­°ï¼šå³ä½¿è»Šå­åœæ­¢ï¼Œä¹Ÿå›å‚³å¯¦æ™‚æ„Ÿæ¸¬å™¨å€¼ã€‚å‰ç«¯å¯ä»¥é¸æ“‡æ˜¯å¦é¡¯ç¤ºã€‚
    doc["leftSensor"] = analogRead(LEFT_SENSOR_PIN);
    doc["rightSensor"] = analogRead(RIGHT_SENSOR_PIN);
    
  switch (currentMotionState) {
    case FORWARD: doc["state"] = "FORWARD"; break;
    case BACKWARD: doc["state"] = "BACKWARD"; break;
    case TURN_LEFT: doc["state"] = "TURN_LEFT"; break;
    case TURN_RIGHT: doc["state"] = "TURN_RIGHT"; break;
    default: doc["state"] = "STOPPED"; break;
  }

  String jsonResponse;
    serializeJson(doc, jsonResponse);
    server.send(200, "application/json", jsonResponse);
  });

  // è™•ç†æœªæ‰¾åˆ°çš„è·¯ç”±
  server.onNotFound([](){
    server.send(404, "text/plain", "Not Found");
  });
}

void startSoftAP() {
  const char* ap_ssid = "ESP32-Car-Control";
  const char* ap_password = "12345678"; // Optional, min 8 chars

  WiFi.mode(WIFI_AP);
  WiFi.softAP(ap_ssid, ap_password);

  IPAddress IP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(IP);  // Usually 192.168.4.1

  startWebServer();    // Launch your web server here
  server.begin();
  Serial.println("Web Server Started! Access at http://" + IP.toString());
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("ESP32-C3 Car Control Starting...");

  // --- é¦¬é”èˆ‡ LED å¼•è…³è¨­å®š (ç¢ºä¿é¦¬é”åœ¨ Wi-Fi é€£æ¥å‰æ˜¯éœæ­¢çš„) ---
  // è¨­å®šé¦¬é”é©…å‹•ç‰ˆçš„æ§åˆ¶å¼•è…³ç‚ºè¼¸å‡ºæ¨¡å¼
  pinMode(MOTOR_SDBY, OUTPUT);
  pinMode(MOTOR_A_IN1, OUTPUT);
  pinMode(MOTOR_A_IN2, OUTPUT);
  pinMode(MOTOR_B_IN3, OUTPUT);
  pinMode(MOTOR_B_IN4, OUTPUT);
  // **ç¢ºä¿é¦¬é”åœ¨é–‹æ©Ÿæ™‚æ˜¯ç¦æ­¢çš„**
  stopMotors(); // å°‡æ‰€æœ‰é¦¬é”ç›¸é—œ PWM å’Œæ–¹å‘å¼•è…³è¨­å®šç‚ºåœæ­¢ç‹€æ…‹

  // LED è…³ä½è¨­å®š
  pinMode(LED_PIN, OUTPUT);
  // åœ¨ Wi-Fi é€£æ¥å‰ï¼ŒLED æ‡‰è™•æ–¼é–ƒçˆç‹€æ…‹ (ç”± loop() ä¸­çš„ updateLED() è™•ç†)
  // æ­¤è™•ä¸éœ€è¦åˆå§‹åŒ–çš„ digitalWrite(LED_PIN, HIGH);

  connectToWiFi();
  setupOTA();
  startWebServer();
  server.begin();
  Serial.println("Web Server Started! Access at http://" + WiFi.localIP().toString());

  // TCRT5000 æ„Ÿæ¸¬å™¨å¼•è…³ç‚ºé¡æ¯”è¼¸å…¥ï¼Œé€šå¸¸ä¸éœ€è¦æ˜ç¢ºè¨­å®š pinMode

}

void loop() {
  // --- OTA è™•ç† ---
  ArduinoOTA.handle();

  // --- è™•ç†ç¶²é å®¢æˆ¶ç«¯è«‹æ±‚ ---
  server.handleClient();

  // --- è®€å– TCRT5000 æ„Ÿæ¸¬å™¨æ•¸æ“š ---
  // ä¸è«–é¦¬é”ç‹€æ…‹å¦‚ä½•ï¼Œéƒ½è®€å–æ„Ÿæ¸¬å™¨å€¼
  int leftSensorValue = analogRead(LEFT_SENSOR_PIN);
  int rightSensorValue = analogRead(RIGHT_SENSOR_PIN);

  // --- åœ¨åºåˆ—åŸ ç›£æ§å™¨é¡¯ç¤ºç‹€æ…‹è¨Šæ¯ ---
  // åªæœ‰ç•¶ Wi-Fi é€£æ¥æˆåŠŸå¾Œæ‰æ­£å¸¸é¡¯ç¤ºè»Šå­ç‹€æ…‹
  if (wifiConnected) {
    if (currentMotionState != STOPPED) {
      String statusMessage = "Mode: ";
      if (currentControlMode == AUTO_CONTROL) {
        statusMessage += "AUTO";
      } else {
        statusMessage += "MANUAL";
      }
      statusMessage += "\tL_Sens: " + String(leftSensorValue);
      statusMessage += "\tR_Sens: " + String(rightSensorValue);
      Serial.println(statusMessage);
      stoppedMessagePrinted = false; // é‡ç½®æ——æ¨™ï¼Œå› ç‚ºè»Šå­æ­£åœ¨ç§»å‹•
    } else {
      if (!stoppedMessagePrinted) {
        Serial.println("Car is stopped."); // æ›´ç°¡æ½”çš„åœæ­¢è¨Šæ¯
        stoppedMessagePrinted = true;
      }
      // åœæ­¢æ™‚ä¸å†é¡¯ç¤ºæ„Ÿæ¸¬å™¨å€¼ï¼Œé¿å…åˆ·å±
    }
  } else {
    // Wi-Fi æœªé€£æ¥æ™‚ï¼ŒupdateLED() æœƒè™•ç† LED é–ƒçˆï¼Œæ­¤è™•ç„¡éœ€é¡å¤–æ—¥èªŒï¼Œé¿å…æ··æ·†ã€‚
    // å¦‚æœéœ€è¦ï¼Œå¯ä»¥åœ¨é€™è£¡æ‰“å°ç°¡æ½”çš„ Wi-Fi é€£ç·šé€²åº¦ã€‚
    if (!stoppedMessagePrinted) {
      Serial.println("Wi-Fi not connected, motors stopped.");
      stoppedMessagePrinted = true; // ç¢ºä¿åªæ‰“å°ä¸€æ¬¡
    }
  }

  // --- æ ¹æ“šæ§åˆ¶æ¨¡å¼åŸ·è¡Œé¦¬é”æ§åˆ¶é‚è¼¯ ---
  // åªæœ‰ç•¶ Wi-Fi é€£æ¥æˆåŠŸå¾Œï¼Œæ‰å…è¨±é¦¬é”åŸ·è¡ŒæŒ‡ä»¤ï¼ˆå¦å‰‡æ‡‰ä¿æŒåœæ­¢ï¼‰
  if (wifiConnected) {
    if (currentControlMode == AUTO_CONTROL) {
      // åˆ¤æ–·éšœç¤™ç‰©ä¸¦æ§åˆ¶é¦¬é” (è‡ªå‹•æ¨¡å¼)
      if (leftSensorValue < OBSTACLE_THRESHOLD && rightSensorValue < OBSTACLE_THRESHOLD) {
        // å…©é‚Šéƒ½åµæ¸¬åˆ°éšœç¤™ç‰© (æˆ–åœ¨ç·šä¸Š)ï¼Œåœæ­¢æˆ–æ¸›é€Ÿ
        Serial.println("Both obstacles detected - Stopping!");
        stopMotors();
      } else if (leftSensorValue < OBSTACLE_THRESHOLD) {
        // å·¦é‚Šåµæ¸¬åˆ°éšœç¤™ç‰©ï¼Œå‘å³å¾®èª¿
        Serial.println("Left obstacle detected - Turning right.");
        turnRight(TURN_SLOW_SPEED); // ä½¿ç”¨å¾®èª¿é€Ÿåº¦
      } else if (rightSensorValue < OBSTACLE_THRESHOLD) {
        // å³é‚Šåµæ¸¬åˆ°éšœç¤™ç‰©ï¼Œå‘å·¦å¾®èª¿
        Serial.println("Right obstacle detected - Turning left.");
        turnLeft(TURN_SLOW_SPEED); // ä½¿ç”¨å¾®èª¿é€Ÿåº¦
      } else {
        // æ²’æœ‰åµæ¸¬åˆ°éšœç¤™ç‰©ï¼Œç›´è¡Œ
        Serial.println("No obstacle - Moving straight.");
        moveForward(STRAIGHT_SPEED);
      }
    }
  } else {
    // Wi-Fi æœªé€£æ¥æ™‚ï¼Œç¢ºä¿é¦¬é”ä¿æŒåœæ­¢ç‹€æ…‹
    stopMotors();
  }

  // æ›´æ–° LED ç‹€æ…‹
  updateLED();

  delay(50); // çŸ­æš«å»¶é²ï¼Œä»¥ä¾¿æ„Ÿæ¸¬å™¨è®€å–å’Œé¦¬é”éŸ¿æ‡‰
}

// === LED ç‹€æ…‹æ§åˆ¶å‡½å¼ ===
void updateLED() {
  unsigned long now = millis();
  unsigned long blinkInterval = 500;

  if (!wifiConnected) {
    // Wi-Fi æœªé€£æ¥ï¼šå¿«é€Ÿé–ƒçˆ
    blinkInterval = 200;
    if (now - lastBlinkTime >= blinkInterval) {
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState ? LOW : HIGH);
      lastBlinkTime = now;
    }
    return;
  }

  // Wi-Fi å·²é€£æ¥å¾Œï¼Œä¾æ“šå‹•ä½œç‹€æ…‹åˆ‡æ› LED æ¨¡å¼
  switch (currentMotionState) {
    case FORWARD:
    case BACKWARD:
      digitalWrite(LED_PIN, LOW); // é•·äº®
      break;
    case TURN_LEFT:
    case TURN_RIGHT:
      if (now - lastBlinkTime >= blinkInterval) {
        ledState = !ledState;
        digitalWrite(LED_PIN, ledState ? LOW : HIGH);
        lastBlinkTime = now;
      }
      break;
    case STOPPED:
    default:
      digitalWrite(LED_PIN, HIGH); // ç†„æ»…ï¼ˆHIGH è¡¨ç¤ºé—œé–‰ï¼‰
      break;
  }
}
/*
void updateLED() {
  unsigned long now = millis();
  unsigned long blinkInterval = 500; // é è¨­é–ƒçˆé »ç‡

  if (!wifiConnected) {
    // Wi-Fi æœªé€£æ¥æ™‚ï¼ŒæŒçºŒé–ƒçˆ
    blinkInterval = 200; // Wi-Fi é€£æ¥å‰æ›´å¿«é–ƒçˆ
    if (now - lastBlinkTime >= blinkInterval) {
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState ? LOW : HIGH);
      lastBlinkTime = now;
    }
  } else {
    // Wi-Fi é€£æ¥æˆåŠŸå¾Œï¼Œæ ¹æ“šé¦¬é”ç‹€æ…‹æ§åˆ¶ LED
    if (currentMotionState == FORWARD) {
      digitalWrite(LED_PIN, LOW); // å‰é€² â†’ é—œç‡ˆ (æˆ–æ‚¨å¸Œæœ›çš„æŒ‡ç¤º)
    } else if (currentMotionState == STOPPED) {
      digitalWrite(LED_PIN, HIGH); // åœæ­¢ â†’ äº®ç‡ˆ (æˆ–æ‚¨å¸Œæœ›çš„æŒ‡ç¤º)
    } else { // OTHER (è½‰å½ã€å¾Œé€€)
      // è½‰å½ã€å¾Œé€€ â†’ é–ƒçˆ
      blinkInterval = 500; // è¼ƒæ…¢é–ƒçˆ
      if (now - lastBlinkTime >= blinkInterval) {
        ledState = !ledState;
        digitalWrite(LED_PIN, ledState ? LOW : HIGH);
        lastBlinkTime = now;
      }
    }
  }
}
*/
// === é¦¬é”å‹•ä½œå‡½å¼ ===
void stopMotors() {
  digitalWrite(MOTOR_SDBY, LOW);
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN3, LOW);
  digitalWrite(MOTOR_B_IN4, LOW);
  currentMotionState = STOPPED;
}

void moveForward(int speed) {
  digitalWrite(MOTOR_SDBY, HIGH);
  digitalWrite(MOTOR_A_IN1, HIGH);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN3, HIGH);
  digitalWrite(MOTOR_B_IN4, LOW);
  currentMotionState = FORWARD;
}

void moveBackward(int speed) {
  digitalWrite(MOTOR_SDBY, HIGH);
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, HIGH);
  digitalWrite(MOTOR_B_IN3, LOW);
  digitalWrite(MOTOR_B_IN4, HIGH);
  currentMotionState = BACKWARD;
}

void turnLeft(int speed) {
  digitalWrite(MOTOR_SDBY, HIGH);
  // A éœæ­¢
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, LOW);
  // B å·¦è½‰æ–¹å‘ï¼ˆæ ¹æ“šé›»è·¯èª¿æ•´æ–¹å‘ï¼‰
  digitalWrite(MOTOR_B_IN3, HIGH);
  digitalWrite(MOTOR_B_IN4, LOW);
  currentMotionState = TURN_LEFT;
}

void turnRight(int speed) {
  digitalWrite(MOTOR_SDBY, HIGH);
  // A éœæ­¢
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, LOW);
  // B å³è½‰æ–¹å‘ï¼ˆæ ¹æ“šé›»è·¯èª¿æ•´æ–¹å‘ï¼‰
  digitalWrite(MOTOR_B_IN3, LOW);
  digitalWrite(MOTOR_B_IN4, HIGH);
  currentMotionState = TURN_RIGHT;
}
/*
void turnLeft(int speed) {
  digitalWrite(MOTOR_SDBY, HIGH);
  digitalWrite(MOTOR_A_IN1, HIGH);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN3, LOW);
  digitalWrite(MOTOR_B_IN4, LOW);
  currentMotionState = TURN_LEFT;
}

void turnRight(int speed) {
  digitalWrite(MOTOR_SDBY, HIGH);
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN3, HIGH);
  digitalWrite(MOTOR_B_IN4, LOW);
  currentMotionState = TURN_RIGHT;
}
*/