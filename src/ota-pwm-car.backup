#include <Arduino.h>     // åŒ…å« Arduino æ ¸å¿ƒå‡½å¼åº«
#include <WiFi.h>        // åŒ…å« Wi-Fi å‡½å¼åº«
#include <ESPmDNS.h>     // åŒ…å« mDNS å‡½å¼åº«ï¼Œç”¨æ–¼é€éä¸»æ©Ÿåç¨±è¨ªå•
#include <WiFiUdp.h>     // åŒ…å« UDP å‡½å¼åº«ï¼ŒOTA éœ€è¦ä½¿ç”¨
#include <ArduinoOTA.h>  // åŒ…å« Arduino OTA å‡½å¼åº«
#include <WebServer.h>   // åŒ…å«ç¶²é ä¼ºæœå™¨å‡½å¼åº« (åŒæ­¥å¼çš„ WebServer)
#include <ArduinoJson.h> // ç”¨æ–¼è™•ç† JSON æ•¸æ“šï¼Œä¾‹å¦‚ç™¼é€æ„Ÿæ¸¬å™¨ç‹€æ…‹

// å‡½å¼å‰å‘å®£å‘Š (Function prototypes)
void stopMotors();
void moveForward(int speed);
void moveBackward(int speed);
void turnLeft(int speed);
void turnRight(int speed);
void updateLED(); // LED ç‹€æ…‹æ›´æ–°å‡½å¼
void handleCarCommand(char command); // çµ±ä¸€è™•ç†è»Šè¼›æŒ‡ä»¤

// Wi-Fi è¨­å®š
const char* ssid = "chen";     // æ›¿æ›æˆæ‚¨çš„ Wi-Fi åç¨±
const char* password = "12345678"; // æ›¿æ›æˆæ‚¨çš„ Wi-Fi å¯†ç¢¼
const char* ota_hostname = "car-esp32c3"; // OTA è£ç½®åœ¨ç¶²è·¯ä¸Šçš„åç¨±
// const char* ota_password = "admin"; // å¦‚æœéœ€è¦ OTA å¯†ç¢¼ï¼Œè«‹å–æ¶ˆè¨»è§£ä¸¦è¨­å®š

// æ§åˆ¶æ¨¡å¼å®šç¾©
enum ControlMode {
  AUTO_CONTROL,   // è‡ªå‹•æ§åˆ¶æ¨¡å¼ (å¾ªç·š/é¿éšœ)
  MANUAL_CONTROL  // æ‰‹å‹•æ§åˆ¶æ¨¡å¼ (ç¶²é æŒ‡ä»¤)
};
ControlMode currentControlMode = MANUAL_CONTROL; // é è¨­ç‚ºæ‰‹å‹•æ§åˆ¶æ¨¡å¼

// é¦¬é”é è¨­é€Ÿåº¦ (0-255ï¼Œå–æ±ºæ–¼ PWM_RESOLUTION)
const int STRAIGHT_SPEED = 250; // ç›´è¡Œé€Ÿåº¦
const int TURN_SPEED = 200;     // è½‰å‘æ™‚è¼ƒå¿«çš„é¦¬é”é€Ÿåº¦ (ç”¨æ–¼åŸåœ°è½‰å‘æˆ–å¤§è½‰å½)
const int TURN_SLOW_SPEED = 150; // è½‰å‘æ™‚è¼ƒæ…¢çš„é¦¬é”é€Ÿåº¦ (ç”¨æ–¼å¾®èª¿)
const int STOP_SPEED = 0;       // åœæ­¢é€Ÿåº¦

// æ„Ÿæ¸¬å™¨é–¾å€¼
// æ­¤å€¼éœ€è¦æ ¹æ“šæ‚¨çš„ TCRT5000 æ„Ÿæ¸¬å™¨å’Œç’°å¢ƒé€²è¡Œæ ¡æº–ã€‚
// å‡è¨­è®€æ•¸ä½æ–¼æ­¤é–¾å€¼è¡¨ç¤ºåµæ¸¬åˆ°éšœç¤™ç‰©æˆ–æ·±è‰²ç·šã€‚
const int OBSTACLE_THRESHOLD = 300; // èª¿æ•´æ­¤å€¼

// é¦¬é”æ§åˆ¶è…³ä½å®šç¾©
// !!! é‡è¦ï¼šè«‹å‹™å¿…æ ¹æ“šæ‚¨çš„å¯¦éš›æ¥ç·šï¼Œå°‡é€™äº› GPIO è™Ÿç¢¼è¨­å®šæ­£ç¢º !!!
// ç›®å‰çš„è®Šæ•¸å€¼ (9, 10, 20, 21) èˆ‡æ‚¨çš„è¨»è§£ (D2, D3, D4, D5) ä¸ç¬¦ã€‚
// å¦‚æœ D2, D3, D4, D5 æ˜¯æ‚¨å¯¦éš›æ¥ç·šçš„ GPIO è™Ÿç¢¼ï¼Œå‰‡æ‡‰æ”¹ç‚º 2, 3, 4, 5
const int MOTOR_A_PWM_PIN = 1;  // å‡è¨­æ¥åˆ° TC1508A IN1
const int MOTOR_A_DIR_PIN = 2; // å‡è¨­æ¥åˆ° TC1508A IN2
const int MOTOR_B_PWM_PIN = 3; // å‡è¨­æ¥åˆ° TC1508A IN3
const int MOTOR_B_DIR_PIN = 4; // å‡è¨­æ¥åˆ° TC1508A IN4

// PWM è¨­å®š
const int PWM_FREQ = 5000;      // PWM é »ç‡ (Hz)
const int PWM_RESOLUTION = 8;   // PWM è§£æåº¦ (8 ä½å…ƒï¼Œå³ 0-255)
const int MOTOR_A_PWM_CHANNEL = 0; // é¦¬é” A çš„ PWM é€šé“
const int MOTOR_B_PWM_CHANNEL = 1; // é¦¬é” B çš„ PWM é€šé“

// TCRT5000 å¾ªç·šæ„Ÿæ¸¬å™¨çš„é¡æ¯”è¼¸å…¥å¼•è…³
const int LEFT_SENSOR_PIN = 0;  // å·¦é‚Š TCRT5000 A0 æ¥åˆ° ESP32-C3 çš„ GPIO4
const int RIGHT_SENSOR_PIN = 0; // å³é‚Š TCRT5000 A0 æ¥åˆ° ESP32-C3 çš„ GPIO3

// æ¿è¼‰ LED è…³ä½
const int LED_PIN = 8;

// å‹•ä½œç‹€æ…‹å®šç¾©
enum MotionState { STOPPED, FORWARD, OTHER };
MotionState currentMotionState = STOPPED; // ä½¿ç”¨ä¸åŒçš„è®Šæ•¸åé¿å…èˆ‡ currentControlMode è¡çª

unsigned long lastBlinkTime = 0;
bool ledState = false;

// å…¨å±€æ——æ¨™ï¼Œç”¨æ–¼è¿½è¹¤ Wi-Fi é€£ç·šç‹€æ…‹
bool wifiConnected = false;

// å…¨å±€è®Šæ•¸ï¼Œç”¨æ–¼æ§åˆ¶åºåˆ—åŸ å’Œç¶²é æ„Ÿæ¸¬å™¨é¡¯ç¤ºçš„é‚è¼¯
static bool stoppedMessagePrinted = false;

// Web Server ç‰©ä»¶
WebServer server(80); // ç¶²é ä¼ºæœå™¨ç›£è½ 80 åŸ 

// çµ±ä¸€è™•ç†è»Šè¼›æŒ‡ä»¤çš„å‡½å¼
void handleCarCommand(char command) {
    String responseMessage = "";

    switch (command) {
        case 'A': // åˆ‡æ›åˆ°è‡ªå‹•æ§åˆ¶æ¨¡å¼
            currentControlMode = AUTO_CONTROL;
            responseMessage = "Switched to AUTO_CONTROL mode.";
            break;
        case 'M': // åˆ‡æ›åˆ°æ‰‹å‹•æ§åˆ¶æ¨¡å¼
            currentControlMode = MANUAL_CONTROL;
            responseMessage = "Switched to MANUAL_CONTROL mode.";
            stopMotors(); // åˆ‡æ›æ¨¡å¼æ™‚åœæ­¢é¦¬é”
            break;
        case 'F': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å‰
            if (currentControlMode == MANUAL_CONTROL) {
                moveForward(STRAIGHT_SPEED);
                responseMessage = "Moving Forward.";
            }
            break;
        case 'B': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å¾Œ
            if (currentControlMode == MANUAL_CONTROL) {
                moveBackward(STRAIGHT_SPEED);
                responseMessage = "Moving Backward.";
            }
            break;
        case 'L': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å·¦è½‰
            if (currentControlMode == MANUAL_CONTROL) {
                turnLeft(TURN_SPEED);
                responseMessage = "Turning Left.";
            }
            break;
        case 'R': // æ‰‹å‹•æ¨¡å¼ï¼šå‘å³è½‰
            if (currentControlMode == MANUAL_CONTROL) {
                turnRight(TURN_SPEED);
                responseMessage = "Turning Right.";
            }
            break;
        case 'S': // æ‰‹å‹•æ¨¡å¼ï¼šåœæ­¢
            if (currentControlMode == MANUAL_CONTROL) {
                stopMotors();
                responseMessage = "Stopping Motors.";
            }
            break;
        default:
            responseMessage = "Unknown Command.";
            break;
    }
    Serial.println(responseMessage);
}

// -------- WiFi é€£ç·š --------
void connectToWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("ğŸ”Œ Connecting to WiFi");

  unsigned long startAttemptTime = millis();

  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 20000) {
    Serial.print(".");
    delay(500);
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nâœ… WiFi Connected");
    Serial.print("ğŸŒ IP Address: ");
    wifiConnected = true; // è¨­å®š Wi-Fi é€£ç·šæ——æ¨™ç‚º true
    digitalWrite(LED_PIN, LOW); // Wi-Fi é€£ç·šæˆåŠŸå¾Œï¼ŒLED ç†„æ»…
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nâŒ WiFi Failed");
    Serial.print("WiFi Status Code: ");
    Serial.println(WiFi.status());
  }
}

// -------- OTA åˆå§‹åŒ– --------
void setupOTA() {
  ArduinoOTA.setHostname(ota_hostname);

  ArduinoOTA.onStart([]() {
    Serial.println("ğŸ” OTA Start");
  });
  ArduinoOTA.onEnd([]() {
    Serial.println("âœ… OTA End");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("ğŸ“¦ Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("âŒ OTA Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });

  ArduinoOTA.begin();
  Serial.println("ğŸ†— OTA Ready.");
}

// -------- Web Server åˆå§‹åŒ– --------
void startWebServer() {
  // --- ç¶²é ä¼ºæœå™¨è·¯ç”±è¨­å®š ---
  // è™•ç†æ ¹è·¯å¾‘è«‹æ±‚ï¼Œæä¾› HTML æ§åˆ¶é é¢
  server.on("/", HTTP_GET, [](){
    server.send_P(200, "text/html", R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32C3 Car Control</title>
    <style>
        body { font-family: 'Inter', sans-serif; text-align: center; margin: 0; padding: 20px; background-color: #f0f0f0; color: #333; }
        .container { max-width: 400px; margin: 20px auto; background-color: #fff; padding: 20px; border-radius: 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        h1 { color: #007bff; margin-bottom: 20px; }
        .controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
        .mode-toggle-button { margin-bottom: 20px; } /* New class for the single mode button */
        button {
            width: 100%; padding: 15px; font-size: 1.2em; border: none; border-radius: 10px;
            cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        button.move { background-color: #28a745; color: white; }
        button.stop { background-color: #dc3545; color: white; }
        button.mode-toggle { background-color: #ffc107; color: #333; } /* Style for the toggle button */
        button:active { transform: translateY(2px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #status { font-size: 1.1em; color: #555; margin-top: 15px; padding: 10px; background-color: #e9ecef; border-radius: 8px; }
        .sensor-data { font-weight: bold; color: #007bff; }
        /* Initially hide manual controls */
        #manualControls { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>è‡ªèµ°è»Šæ§åˆ¶</h1>

        <div class="mode-toggle-button">
            <button id="toggleModeBtn" class="mode-toggle" onclick="toggleMode()">åˆ‡æ›åˆ°æ‰‹å‹•æ¨¡å¼</button>
        </div>

        <div id="manualControls" class="controls">
            <div></div><button class="move" onclick="sendCommand('F')">å‰é€²</button><div></div>
            <button class="move" onclick="sendCommand('L')">å·¦è½‰</button>
            <button class="stop" onclick="sendCommand('S')">åœæ­¢</button>
            <button class="move" onclick="sendCommand('R')">å³è½‰</button>
            <div></div><button class="move" onclick="sendCommand('B')">å¾Œé€€</button><div></div>
        </div>

        <div class="status-display">
            <h2>ç‹€æ…‹</h2>
            <p id="status">æ­£åœ¨é€£æ¥...</p>
        </div>
    </div>

    <script>
        const statusElement = document.getElementById('status');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        const manualControls = document.getElementById('manualControls');

        let currentLocalMode = 'AUTO'; // Keep track of the mode locally

        async function sendCommand(cmd) {
            try {
                const response = await fetch(`/control?cmd=${cmd}`);
                const text = await response.text();
                console.log(text);
                await updateStatus(); // Update status immediately after command
            } catch (error) {
                console.error('Error sending command:', error);
                statusElement.textContent = 'éŒ¯èª¤: ç„¡æ³•ç™¼é€æŒ‡ä»¤';
            }
        }

        async function toggleMode() {
            const newMode = (currentLocalMode === 'AUTO') ? 'M' : 'A';
            try {
                const response = await fetch(`/mode?set=${newMode}`);
                const text = await response.text();
                console.log(text);
                // Update local mode and UI based on successful response
                currentLocalMode = (newMode === 'A') ? 'AUTO' : 'MANUAL';
                updateModeUI();
                await updateStatus(); // Fetch actual status from ESP32
            } catch (error) {
                console.error('Error toggling mode:', error);
                statusElement.textContent = 'éŒ¯èª¤: ç„¡æ³•è¨­å®šæ¨¡å¼';
            }
        }

        function updateModeUI() {
            if (currentLocalMode === 'MANUAL') {
                toggleModeBtn.textContent = 'åˆ‡æ›åˆ°è‡ªå‹•æ¨¡å¼';
                manualControls.style.display = 'grid'; // Show grid for controls
            } else {
                toggleModeBtn.textContent = 'åˆ‡æ›åˆ°æ‰‹å‹•æ¨¡å¼';
                manualControls.style.display = 'none'; // Hide controls
            }
        }

        async function updateStatus() {
            try {
                const response = await fetch('/status');
                const data = await response.json();
                statusElement.innerHTML = `
                    æ¨¡å¼: <span class="sensor-data">${data.mode}</span><br>
                    å·¦æ„Ÿæ¸¬å™¨: <span class="sensor-data">${data.leftSensor}</span><br>
                    å³æ„Ÿæ¸¬å™¨: <span class="sensor-data">${data.rightSensor}</span>
                `;
                // Ensure local mode and UI are in sync with ESP32's actual mode
                const esp32Mode = data.mode;
                if (esp32Mode === 'MANUAL' && currentLocalMode !== 'MANUAL') {
                    currentLocalMode = 'MANUAL';
                    updateModeUI();
                } else if (esp32Mode === 'AUTO' && currentLocalMode !== 'AUTO') {
                    currentLocalMode = 'AUTO';
                    updateModeUI();
                }

            } catch (error) {
                console.error('Error fetching status:', error);
                statusElement.textContent = 'éŒ¯èª¤: ç„¡æ³•ç²å–ç‹€æ…‹';
            }
        }

        // Initial setup and periodic updates
        document.addEventListener('DOMContentLoaded', () => {
            updateStatus(); // Fetch initial status
            setInterval(updateStatus, 1000); // Periodically update status
        });
    </script>
</body>
</html>
)rawliteral");
  });

  // è™•ç†æ§åˆ¶æŒ‡ä»¤ (GET è«‹æ±‚)
  server.on("/control", HTTP_GET, [](){
    if (server.hasArg("cmd")) {
      String cmd = server.arg("cmd");
      handleCarCommand(cmd.charAt(0)); // çµ±ä¸€è™•ç†æŒ‡ä»¤
      server.send(200, "text/plain", "Command received: " + cmd);
    } else {
      server.send(400, "text/plain", "No command specified");
    }
  });

  // è™•ç†æ¨¡å¼åˆ‡æ›æŒ‡ä»¤ (GET è«‹æ±‚)
  server.on("/mode", HTTP_GET, [](){
    if (server.hasArg("set")) {
      String mode = server.arg("set");
      handleCarCommand(mode.charAt(0)); // 'A' æˆ– 'M'
      server.send(200, "text/plain", "Mode set to: " + mode);
    } else {
      server.send(400, "text/plain", "No mode specified");
    }
  });

  // æä¾›æ„Ÿæ¸¬å™¨ç‹€æ…‹ (JSON æ ¼å¼)
  server.on("/status", HTTP_GET, [](){
    StaticJsonDocument<200> doc; // ArduinoJson æ–‡æª”
    doc["mode"] = (currentControlMode == AUTO_CONTROL) ? "AUTO" : "MANUAL";

    // å»ºè­°ï¼šå³ä½¿è»Šå­åœæ­¢ï¼Œä¹Ÿå›å‚³å¯¦æ™‚æ„Ÿæ¸¬å™¨å€¼ã€‚å‰ç«¯å¯ä»¥é¸æ“‡æ˜¯å¦é¡¯ç¤ºã€‚
    doc["leftSensor"] = analogRead(LEFT_SENSOR_PIN);
    doc["rightSensor"] = analogRead(RIGHT_SENSOR_PIN);
    
    String jsonResponse;
    serializeJson(doc, jsonResponse);
    server.send(200, "application/json", jsonResponse);
  });

  // è™•ç†æœªæ‰¾åˆ°çš„è·¯ç”±
  server.onNotFound([](){
    server.send(404, "text/plain", "Not Found");
  });
}

void startSoftAP() {
  const char* ap_ssid = "ESP32-Car-Control";
  const char* ap_password = "12345678"; // Optional, min 8 chars

  WiFi.mode(WIFI_AP);
  WiFi.softAP(ap_ssid, ap_password);

  IPAddress IP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(IP);  // Usually 192.168.4.1

  startWebServer();    // Launch your web server here
  server.begin();
  Serial.println("Web Server Started! Access at http://" + IP.toString());
}

void testMotorAForward() {
  Serial.println("Test Motor A Forward");
  digitalWrite(5, LOW);             // DIR LOW = å‘å‰ï¼Ÿ
  ledcWrite(0, 150);                // PWM è…³ï¼šGPIO 4
  delay(2000);
  ledcWrite(0, 0);
}

void testMotorABackward() {
  Serial.println("Test Motor A Backward");
  digitalWrite(5, HIGH);            // DIR HIGH = å‘å¾Œï¼Ÿ
  ledcWrite(0, 150);                // PWM è…³ï¼šGPIO 4
  delay(2000);
  ledcWrite(0, 0);
}

void testMotorBForward() {
  Serial.println("Test Motor B Forward");
  digitalWrite(7, LOW);             // DIR LOW = å‘å‰ï¼Ÿ
  ledcWrite(1, 150);                // PWM è…³ï¼šGPIO 6
  delay(2000);
  ledcWrite(1, 0);
}

void testMotorBBackward() {
  Serial.println("Test Motor B Backward");
  digitalWrite(7, HIGH);            // DIR HIGH = å‘å¾Œï¼Ÿ
  ledcWrite(1, 150);                // PWM è…³ï¼šGPIO 6
  delay(2000);
  ledcWrite(1, 0);
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("ESP32-C3 Car Control Starting...");

  // --- é¦¬é”èˆ‡ LED å¼•è…³è¨­å®š (ç¢ºä¿é¦¬é”åœ¨ Wi-Fi é€£æ¥å‰æ˜¯éœæ­¢çš„) ---
  // è¨­å®š TC1508A æ§åˆ¶å¼•è…³ç‚ºè¼¸å‡ºæ¨¡å¼
  pinMode(MOTOR_A_PWM_PIN, OUTPUT);
  pinMode(MOTOR_A_DIR_PIN, OUTPUT);
  pinMode(MOTOR_B_PWM_PIN, OUTPUT);
  pinMode(MOTOR_B_DIR_PIN, OUTPUT);

  // è¨­å®š PWM é€šé“
  ledcSetup(MOTOR_A_PWM_CHANNEL, PWM_FREQ, PWM_RESOLUTION);
  ledcSetup(MOTOR_B_PWM_CHANNEL, PWM_FREQ, PWM_RESOLUTION);

  // å°‡ PWM é€šé“èˆ‡ GPIO å¼•è…³ç¶å®š
  ledcAttachPin(MOTOR_A_PWM_PIN, MOTOR_A_PWM_CHANNEL);
  ledcAttachPin(MOTOR_B_PWM_PIN, MOTOR_B_PWM_CHANNEL);
/*
delay(1000);
testMotorAForward();
delay(1000);
testMotorABackward();
delay(1000);
testMotorBForward();
delay(1000);
testMotorBBackward();
delay(1000);
*/
  // **ç¢ºä¿é¦¬é”åœ¨é–‹æ©Ÿæ™‚æ˜¯ç¦æ­¢çš„**
  stopMotors(); // å°‡æ‰€æœ‰é¦¬é”ç›¸é—œ PWM å’Œæ–¹å‘å¼•è…³è¨­å®šç‚ºåœæ­¢ç‹€æ…‹

  // LED è…³ä½è¨­å®š
  pinMode(LED_PIN, OUTPUT);
  // åœ¨ Wi-Fi é€£æ¥å‰ï¼ŒLED æ‡‰è™•æ–¼é–ƒçˆç‹€æ…‹ (ç”± loop() ä¸­çš„ updateLED() è™•ç†)
  // æ­¤è™•ä¸éœ€è¦åˆå§‹åŒ–çš„ digitalWrite(LED_PIN, HIGH);

  connectToWiFi();
  setupOTA();
  startWebServer();
  server.begin();
  Serial.println("Web Server Started! Access at http://" + WiFi.localIP().toString());

  // TCRT5000 æ„Ÿæ¸¬å™¨å¼•è…³ç‚ºé¡æ¯”è¼¸å…¥ï¼Œé€šå¸¸ä¸éœ€è¦æ˜ç¢ºè¨­å®š pinMode

}

void loop() {
  // --- OTA è™•ç† ---
  ArduinoOTA.handle();

  // --- è™•ç†ç¶²é å®¢æˆ¶ç«¯è«‹æ±‚ ---
  server.handleClient();

  // --- è®€å– TCRT5000 æ„Ÿæ¸¬å™¨æ•¸æ“š ---
  // ä¸è«–é¦¬é”ç‹€æ…‹å¦‚ä½•ï¼Œéƒ½è®€å–æ„Ÿæ¸¬å™¨å€¼
  int leftSensorValue = analogRead(LEFT_SENSOR_PIN);
  int rightSensorValue = analogRead(RIGHT_SENSOR_PIN);

  // --- åœ¨åºåˆ—åŸ ç›£æ§å™¨é¡¯ç¤ºç‹€æ…‹è¨Šæ¯ ---
  // åªæœ‰ç•¶ Wi-Fi é€£æ¥æˆåŠŸå¾Œæ‰æ­£å¸¸é¡¯ç¤ºè»Šå­ç‹€æ…‹
  if (wifiConnected) {
    if (currentMotionState != STOPPED) {
      String statusMessage = "Mode: ";
      if (currentControlMode == AUTO_CONTROL) {
        statusMessage += "AUTO";
      } else {
        statusMessage += "MANUAL";
      }
      statusMessage += "\tL_Sens: " + String(leftSensorValue);
      statusMessage += "\tR_Sens: " + String(rightSensorValue);
      Serial.println(statusMessage);
      stoppedMessagePrinted = false; // é‡ç½®æ——æ¨™ï¼Œå› ç‚ºè»Šå­æ­£åœ¨ç§»å‹•
    } else {
      if (!stoppedMessagePrinted) {
        Serial.println("Car is stopped."); // æ›´ç°¡æ½”çš„åœæ­¢è¨Šæ¯
        stoppedMessagePrinted = true;
      }
      // åœæ­¢æ™‚ä¸å†é¡¯ç¤ºæ„Ÿæ¸¬å™¨å€¼ï¼Œé¿å…åˆ·å±
    }
  } else {
    // Wi-Fi æœªé€£æ¥æ™‚ï¼ŒupdateLED() æœƒè™•ç† LED é–ƒçˆï¼Œæ­¤è™•ç„¡éœ€é¡å¤–æ—¥èªŒï¼Œé¿å…æ··æ·†ã€‚
    // å¦‚æœéœ€è¦ï¼Œå¯ä»¥åœ¨é€™è£¡æ‰“å°ç°¡æ½”çš„ Wi-Fi é€£ç·šé€²åº¦ã€‚
    if (!stoppedMessagePrinted) {
      Serial.println("Wi-Fi not connected, motors stopped.");
      stoppedMessagePrinted = true; // ç¢ºä¿åªæ‰“å°ä¸€æ¬¡
    }
  }

  // --- æ ¹æ“šæ§åˆ¶æ¨¡å¼åŸ·è¡Œé¦¬é”æ§åˆ¶é‚è¼¯ ---
  // åªæœ‰ç•¶ Wi-Fi é€£æ¥æˆåŠŸå¾Œï¼Œæ‰å…è¨±é¦¬é”åŸ·è¡ŒæŒ‡ä»¤ï¼ˆå¦å‰‡æ‡‰ä¿æŒåœæ­¢ï¼‰
  if (wifiConnected) {
    if (currentControlMode == AUTO_CONTROL) {
      // åˆ¤æ–·éšœç¤™ç‰©ä¸¦æ§åˆ¶é¦¬é” (è‡ªå‹•æ¨¡å¼)
      if (leftSensorValue < OBSTACLE_THRESHOLD && rightSensorValue < OBSTACLE_THRESHOLD) {
        // å…©é‚Šéƒ½åµæ¸¬åˆ°éšœç¤™ç‰© (æˆ–åœ¨ç·šä¸Š)ï¼Œåœæ­¢æˆ–æ¸›é€Ÿ
        Serial.println("Both obstacles detected - Stopping!");
        stopMotors();
      } else if (leftSensorValue < OBSTACLE_THRESHOLD) {
        // å·¦é‚Šåµæ¸¬åˆ°éšœç¤™ç‰©ï¼Œå‘å³å¾®èª¿
        Serial.println("Left obstacle detected - Turning right.");
        turnRight(TURN_SLOW_SPEED); // ä½¿ç”¨å¾®èª¿é€Ÿåº¦
      } else if (rightSensorValue < OBSTACLE_THRESHOLD) {
        // å³é‚Šåµæ¸¬åˆ°éšœç¤™ç‰©ï¼Œå‘å·¦å¾®èª¿
        Serial.println("Right obstacle detected - Turning left.");
        turnLeft(TURN_SLOW_SPEED); // ä½¿ç”¨å¾®èª¿é€Ÿåº¦
      } else {
        // æ²’æœ‰åµæ¸¬åˆ°éšœç¤™ç‰©ï¼Œç›´è¡Œ
        Serial.println("No obstacle - Moving straight.");
        moveForward(STRAIGHT_SPEED);
      }
    }
  } else {
    // Wi-Fi æœªé€£æ¥æ™‚ï¼Œç¢ºä¿é¦¬é”ä¿æŒåœæ­¢ç‹€æ…‹
    stopMotors();
  }

  // æ›´æ–° LED ç‹€æ…‹
  updateLED();

  delay(50); // çŸ­æš«å»¶é²ï¼Œä»¥ä¾¿æ„Ÿæ¸¬å™¨è®€å–å’Œé¦¬é”éŸ¿æ‡‰
}

// === LED ç‹€æ…‹æ§åˆ¶å‡½å¼ ===
void updateLED() {
  unsigned long now = millis();
  unsigned long blinkInterval = 500; // é è¨­é–ƒçˆé »ç‡

  if (!wifiConnected) {
    // Wi-Fi æœªé€£æ¥æ™‚ï¼ŒæŒçºŒé–ƒçˆ
    blinkInterval = 200; // Wi-Fi é€£æ¥å‰æ›´å¿«é–ƒçˆ
    if (now - lastBlinkTime >= blinkInterval) {
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState ? LOW : HIGH);
      lastBlinkTime = now;
    }
  } else {
    // Wi-Fi é€£æ¥æˆåŠŸå¾Œï¼Œæ ¹æ“šé¦¬é”ç‹€æ…‹æ§åˆ¶ LED
    if (currentMotionState == FORWARD) {
      digitalWrite(LED_PIN, LOW); // å‰é€² â†’ é—œç‡ˆ (æˆ–æ‚¨å¸Œæœ›çš„æŒ‡ç¤º)
    } else if (currentMotionState == STOPPED) {
      digitalWrite(LED_PIN, HIGH); // åœæ­¢ â†’ äº®ç‡ˆ (æˆ–æ‚¨å¸Œæœ›çš„æŒ‡ç¤º)
    } else { // OTHER (è½‰å½ã€å¾Œé€€)
      // è½‰å½ã€å¾Œé€€ â†’ é–ƒçˆ
      blinkInterval = 500; // è¼ƒæ…¢é–ƒçˆ
      if (now - lastBlinkTime >= blinkInterval) {
        ledState = !ledState;
        digitalWrite(LED_PIN, ledState ? LOW : HIGH);
        lastBlinkTime = now;
      }
    }
  }
}

// === é¦¬é”å‹•ä½œå‡½å¼ ===
void stopMotors() {
  ledcWrite(MOTOR_A_PWM_CHANNEL, STOP_SPEED); // å°‡ PWM å·¥ä½œé€±æœŸè¨­ç‚º 0
  ledcWrite(MOTOR_B_PWM_CHANNEL, STOP_SPEED);
  digitalWrite(MOTOR_A_DIR_PIN, LOW); // ç¢ºä¿æ–¹å‘å¼•è…³ç‚º LOW (æˆ–ä»»ä½•å®‰å…¨ç‹€æ…‹)
  digitalWrite(MOTOR_B_DIR_PIN, LOW);
  digitalWrite(MOTOR_A_PWM_PIN, LOW);  // IN1
  digitalWrite(MOTOR_B_PWM_PIN, LOW);  // IN3
  currentMotionState = STOPPED; // æ›´æ–°å‹•ä½œç‹€æ…‹
}

void moveForward(int speed) {
  digitalWrite(MOTOR_A_DIR_PIN, LOW); // å³é¦¬é”å‘å‰ (è«‹æ ¹æ“šå¯¦éš›æ¥ç·šèª¿æ•´é«˜ä½é›»ä½)
  digitalWrite(MOTOR_B_DIR_PIN, LOW); // å·¦é¦¬é”å‘å‰ (è«‹æ ¹æ“šå¯¦éš›æ¥ç·šèª¿æ•´é«˜ä½é›»ä½)
  ledcWrite(MOTOR_B_PWM_CHANNEL, speed);
  ledcWrite(MOTOR_A_PWM_CHANNEL, speed);
  currentMotionState = FORWARD; // æ›´æ–°å‹•ä½œç‹€æ…‹
}

void moveBackward(int speed) {
/*  
  testMotorABackward();
  testMotorBBackward();
*/  
  digitalWrite(MOTOR_A_DIR_PIN, HIGH); // å³é¦¬é”å‘å¾Œ (æ–¹å‘èˆ‡å‘å‰ç›¸åï¼Œè«‹æ ¹æ“šå¯¦éš›æ¥ç·šèª¿æ•´)
  digitalWrite(MOTOR_B_DIR_PIN, HIGH); // å·¦é¦¬é”å‘å¾Œ (æ–¹å‘èˆ‡å‘å‰ç›¸åï¼Œè«‹æ ¹æ“šå¯¦éš›æ¥ç·šèª¿æ•´)
  ledcWrite(MOTOR_A_PWM_CHANNEL, speed);
  ledcWrite(MOTOR_B_PWM_CHANNEL, speed);
  currentMotionState = OTHER; // æ›´æ–°å‹•ä½œç‹€æ…‹ (å› ç‚ºæ˜¯å¾Œé€€ï¼Œæ‰€ä»¥æ˜¯ OTHER)
}

// å·®é€Ÿè½‰å‘ (åŸåœ°è½‰å‘è«‹ä¿®æ”¹ DIR_PIN é‚è¼¯)
void turnLeft(int speed) {
  digitalWrite(MOTOR_A_DIR_PIN, LOW); // å³é¦¬é”å‘å‰
  digitalWrite(MOTOR_B_DIR_PIN, LOW); // å·¦é¦¬é”å‘å‰
  ledcWrite(MOTOR_A_PWM_CHANNEL, speed);          // å³é¦¬é”é€Ÿåº¦
  ledcWrite(MOTOR_B_PWM_CHANNEL, TURN_SLOW_SPEED); // å·¦é¦¬é”æ¸›é€Ÿ
  currentMotionState = OTHER; // æ›´æ–°å‹•ä½œç‹€æ…‹ (å› ç‚ºæ˜¯è½‰å½ï¼Œæ‰€ä»¥æ˜¯ OTHER)
}

// å·®é€Ÿè½‰å‘ (åŸåœ°è½‰å‘è«‹ä¿®æ”¹ DIR_PIN é‚è¼¯)
void turnRight(int speed) {
  digitalWrite(MOTOR_A_DIR_PIN, LOW); // å³é¦¬é”å‘å‰
  digitalWrite(MOTOR_B_DIR_PIN, LOW); // å·¦é¦¬é”å‘å‰
  ledcWrite(MOTOR_A_PWM_CHANNEL, TURN_SLOW_SPEED); // å³é¦¬é”æ¸›é€Ÿ
  ledcWrite(MOTOR_B_PWM_CHANNEL, speed);          // å·¦é¦¬é”é€Ÿåº¦
  currentMotionState = OTHER; // æ›´æ–°å‹•ä½œç‹€æ…‹ (å› ç‚ºæ˜¯è½‰å½ï¼Œæ‰€ä»¥æ˜¯ OTHER)
}

// å‡½å¼ï¼šè®“é¦¬é”å‰è»Š (å¦‚æœ TC1508A æ”¯æ´æ­¤æ¨¡å¼ï¼Œé€šå¸¸æ˜¯å°‡å…©å€‹è¼¸å…¥éƒ½è¨­ç‚º HIGH)
// æ­¤å‡½å¼ç›®å‰æœªä½¿ç”¨ï¼Œä½†ä¿ç•™ä¾›åƒè€ƒ
void brakeMotors() {
  // å‰è»Šæ¨¡å¼é€šå¸¸æ˜¯å°‡å…©å€‹æ–¹å‘å¼•è…³éƒ½è¨­ç‚º HIGHï¼Œä¸¦å°‡ PWM è¨­ç‚ºæœ€å¤§æˆ– 0 (å–æ±ºæ–¼é©…å‹•å™¨è¡Œç‚º)
  // é€™è£¡å‡è¨­å°‡å…©å€‹æ–¹å‘å¼•è…³éƒ½è¨­ç‚º HIGH å³å¯å‰è»Š
  digitalWrite(MOTOR_A_DIR_PIN, HIGH);
  digitalWrite(MOTOR_B_DIR_PIN, HIGH);
  ledcWrite(MOTOR_A_PWM_CHANNEL, 0); // åœ¨å‰è»Šæ™‚é€šå¸¸æœƒå°‡ PWM è¨­ç‚º 0
  ledcWrite(MOTOR_B_PWM_CHANNEL, 0);
  currentMotionState = STOPPED; // å‰è»Šé€šå¸¸è¦–ç‚ºåœæ­¢ç‹€æ…‹
}